/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.agh.reactive;

import akka.Done;
import akka.NotUsed;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.japi.Pair;
import akka.stream.*;
import akka.stream.javadsl.*;
import edu.agh.reactive.hello.HelloActor;
import edu.agh.reactive.math.MathActor;


import java.io.IOException;
import java.util.concurrent.CompletionStage;

public class App {
    public static void main(String[] args) {
        //////////////////////////////////////////
        //TASK 0 - hello
        // create actor system
        System.out.println("========== TAKS 0 ==========");

        final ActorSystem<String> helloSystem =
                ActorSystem.create(HelloActor.create(), "helloActor");
        // send messages
        helloSystem.tell("hello world");

        System.out.println("========== TAKS 1 ==========");

        //////////////////////////////////////////
        //TASK 1 - math operations
        final ActorSystem<MathActor.MathCommand> mathContext =
                ActorSystem.create(MathActor.create(), "actorMath");
        System.out.println("math main: actor system ready");

        // send messages
        mathContext.tell(new MathActor.MathCommandAdd(5, 3));
        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
//
        mathContext.tell(new MathActor.MathCommandDivide(15, 0, null));
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
//
        System.out.println("Math main: sending second package of messages");
        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
        System.out.println("Math main: messages send");

        System.out.println("========== TAKS 2 ==========");

        /// TASK 2 - Reactive Streams in Akka Streams
        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
        final Materializer materializer = Materializer.createMaterializer(streamSystem);
        // example how to create simple Akka Streams
        final Source<Integer, NotUsed> source = Source.range(1, 100).buffer(16, OverflowStrategy.dropHead());
        //backpressure(), dropTail()- drops youngest,dropHead() - drops oldest,fail()
        final Flow<Integer, String, NotUsed> flow = Flow.fromFunction((Integer n) -> {
            System.out.println("[Int]" + n);
            return n.toString();
        }).async();
        final Sink<String, CompletionStage<Done>> sink = Sink.foreach(el -> {
            Thread.sleep(1000);
            System.out.println("[Str]" + el);
        });

        final RunnableGraph<NotUsed> runnableGraph = source.via(flow).to(sink);
        runnableGraph.run(materializer);
        // create debugFlow and add slowSink components

        System.out.println("========== TAKS 3 ==========");

        // TASK 3 - graph dsl
        // how to create
        final ActorSystem<Object> graphActor = ActorSystem.create(akka.actor.typed.scaladsl.Behaviors.empty(), "graph");
        final Materializer graphMaterializer = Materializer.createMaterializer(graphActor);

        final Source<Integer, NotUsed> inputSource = Source.range(1,100);
        final Flow<Integer,Integer,NotUsed> addFlow = Flow.of(Integer.class).map(el -> el+1);
        final Flow<Integer,Integer,NotUsed> multiplyFlow = Flow.of(Integer.class).map(el -> el*10);
        final Sink<Pair<Integer,Integer>, CompletionStage<Done>> sink1 = Sink.foreach(System.out::println);

        // step 1 - frame
        final Graph<ClosedShape, CompletionStage<Done>> specialGraph = GraphDSL.create(sink1, (builder, out) -> {
            //step 2 - building blocks
            final UniformFanOutShape<Integer, Integer> broadcast = builder.add(Broadcast.create(2));
            final FanInShape2<Integer,Integer, Pair<Integer,Integer>> zip = builder.add(Zip.create());
            final Outlet<Integer> source1 = builder.add(inputSource).out();

            // step 3 - glue components
            builder.from(source1).toFanOut(broadcast);
            builder.from(broadcast).via(builder.add(addFlow)).toInlet(zip.in0());
            builder.from(broadcast).via(builder.add(multiplyFlow)).toInlet(zip.in1());
            builder.from(zip.out()).to(out);
            // step 4 closing
            return ClosedShape.getInstance();
        });

        RunnableGraph.fromGraph(specialGraph).run(graphMaterializer);

        try {
            System.out.println(">>> Press ENTER to exit <<<");
            System.in.read();
        } catch (IOException ignored) {
        } finally {
            mathContext.terminate();
            helloSystem.terminate();
            streamSystem.terminate();
            graphActor.terminate();
        }
    }
}
